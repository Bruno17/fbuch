  <!-- at end of body, AFTER Quasar script(s): -->
  <script src="https://cdn.jsdelivr.net/npm/@quasar/quasar-ui-qcalendar@next/dist/QCalendarMonth.umd.min.js"></script>

  <!-- If you need Timestamp functions: -->
  <script src="https://cdn.jsdelivr.net/npm/@quasar/quasar-ui-qcalendar@next/dist/Timestamp.umd.min.js"></script>

<script>
    /*
      Example kicking off the UI. Obviously, adapt this to your specific needs.
      Assumes you have a <div id="q-app"></div> in your <body> above
     */
    const { ref, computed } = Vue;
    const { today, padNumber, parsed, isBetweenDates, parseTimestamp, getStartOfMonth, getEndOfMonth, parseDate, isOverlappingDates, daysBetween, indexOf } = QCalendarMonth;

    // The function below is used to set up our demo data
    const CURRENT_DAY = new Date()
    function getCurrentDay (day) {
        const newDay = new Date(CURRENT_DAY)
        newDay.setDate(day)
        const tm = parseDate(newDay)
        return tm.date
    }

    const app = Vue.createApp({
      setup () {
     
        const loadedEvents = ref([]);
        const leftDrawerOpen = ref(false)
        const selectedDate = ref(today()),
        calendar = ref(null),
        locale = 'de-DE',
        startDate = ref(today()),
        endDate = ref(today());

        const selectedYear = computed(() => {
          //const date = new Date(selectedDate.value)
          let ts = parseTimestamp(selectedDate.value)
          return ts.year;
        })        

          const formattedMonth = computed(() => {
          const date = new Date(selectedDate.value)
          return monthFormatter().format(date)
        })
        function monthFormatter () {
          try {
            return new Intl.DateTimeFormat(locale || undefined, {
              month: 'long',
              timeZone: 'UTC'
            })
          }
          catch (e) {
            //
          }
        }
        
        function getWeekEvents (week, weekdays) {
            //console.log('getWeekEvents' , week);
            const firstDay = parsed(week[ 0 ].date + ' 00:00')
            const lastDay = parsed(week[ week.length - 1 ].date + ' 23:59')
            const eventsWeek = []
            loadedEvents.value.forEach((event, id) => {
                const startDate = parsed(event.date)
                const endDate = parsed(event.date_end)

                if (isOverlappingDates(startDate, endDate, firstDay, lastDay)) {
                const left = daysBetween(firstDay, startDate, true)
                const right = daysBetween(endDate, lastDay, true)
                eventsWeek.push({
                    id, // index event
                    left, // Position initial day [0-6]
                    right, // Number days available
                    size: week.length - (left + right), // Size current event (in days)
                    event // Info
                })
                }
            })
            const events = []
            if (eventsWeek.length > 0) {
                const infoWeek = eventsWeek.sort((a, b) => a.left - b.left)
                infoWeek.forEach((_, i) => {
                insertEvent(events, week.length, infoWeek, i, 0, 0)
                })
            }
            return events
        }

        function insertEvent (events, weekLength, infoWeek, index, availableDays, level) {
            const iEvent = infoWeek[ index ]
            if (iEvent !== undefined && iEvent.left >= availableDays) {
                // If you have space available, more events are placed
                if (iEvent.left - availableDays) {
                // It is filled with empty events
                events.push({ size: iEvent.left - availableDays })
                }
                // The event is built
                events.push({ size: iEvent.size, event: iEvent.event })
                if (level !== 0) {
                // If it goes into recursion, then the item is deleted
                infoWeek.splice(index, 1)
                }
                const currentAvailableDays = iEvent.left + iEvent.size
                if (currentAvailableDays < weekLength) {
                const indexNextEvent = indexOf(infoWeek, e => e.id !== iEvent.id && e.left >= currentAvailableDays)
                insertEvent(
                    events,
                    weekLength,
                    infoWeek,
                    indexNextEvent !== -1 ? indexNextEvent : index,
                    currentAvailableDays,
                    level + 1
                )
                } // else: There are no more days available, end of iteration
            }
            else {
                events.push({ size: weekLength - availableDays })
                // end of iteration
            }
        } 
        
        function isBetweenDatesWeek (dateStart, dateEnd, weekStart, weekEnd) {
            return (
                (dateEnd < weekEnd && dateEnd >= weekStart)
                || dateEnd === weekEnd
                || (dateEnd > weekEnd && dateStart <= weekEnd)
            )
        }        

        function onMoved(data) {
            console.log("onMoved", data);
        }

        function loadMonthEvents(){
            let ts = parseTimestamp(selectedDate.value);
            const start = getStartOfMonth(ts).date;
            const end = getEndOfMonth(ts).date;
            const data = {};
            const ajaxUrl = '[[++assets_url]]components/fbuch/rest/Dates';
            data.start = start + ' 00:00:00';
            data.end = end + ' 23:59:59';
            axios.get(ajaxUrl,{params:data})
            .then(function (response) {
               loadedEvents.value = response.data.results;
            })
            .catch(function (error) {
                console.log(error);
            }); 
        }            
            
    function badgeClasses(computedEvent) {
      if (computedEvent.event !== undefined) {
        return {
          'my-event': true,
          'text-white': true,
          [ `bg-${ computedEvent.event.Type_colorstyle }` ]: true,
          'rounded-border': true,
          'q-calendar__ellipsis': true
        }
      }
      return {
        'my-void-event': true
      }
    }

    function badgeStyles(computedEvent, weekLength) {
      const s = {}
      if (computedEvent.size !== undefined) {
        s.width = ((100 / weekLength) * computedEvent.size) + '%'
      }
      return s
    }            

        

        function onChange(data) {
        startDate.value = data.start;
        endDate.value = data.end;
        loadMonthEvents();
        }

        function onClickDate(data) {
        console.log("onClickDate", data);
        }

        function onClickDay(data) {
        console.log("onClickDay", data);
        }

        function onClickHeadDay(data) {
        console.log("onClickHeadDay", data);
        }

        function onToday() {
        selectedDate.value = today();
        }

        function onPrev() {
        calendar.value.prev();
        }

        function onNext() {
        calendar.value.next();
        }

        return {
          selectedDate,
          selectedYear,
          calendar, // ref
          onMoved,
          onChange,
          onClickDate,
          onClickDay,
          onClickHeadDay,
          onToday,
          onPrev,
          onNext,
          leftDrawerOpen,
          formattedMonth,
          loadedEvents,
          getWeekEvents,
          badgeClasses,
          badgeStyles,
          toggleLeftDrawer () {
            leftDrawerOpen.value = !leftDrawerOpen.value
          }
        }
      }
    })

    app.use(Quasar, {
      config: {
        /*
        brand: {
          // primary: '#e46262',
          // ... or all other brand colors
        },
        notify: {...}, // default set of options for Notify Quasar plugin
        loading: {...}, // default set of options for Loading Quasar plugin
        loadingBar: { ... }, // settings for LoadingBar Quasar plugin
        // ..and many more (check Installation card on each Quasar component/directive/plugin)
        */
      }
    })
    Quasar.lang.set(Quasar.lang.de)
    app.component("QCalendarMonth", QCalendarMonth.QCalendarMonth);
    app.mount('#q-app')
  </script>